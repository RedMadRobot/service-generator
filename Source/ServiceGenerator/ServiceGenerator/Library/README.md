# ModelCompilerFramework

Набор компонентов библиотеки может быть использован для получения информации об исходном коде на языке Swift.

**Распознаются:**

* Классы (см. `Klass`), протоколы (см. `Protokol`) и их свойства:
    - Имя
    - Материнский класс
    - Аннотации класса (см. `Annotation`; о формате аннотаций — см. ниже)
    - Набор свойств (см. `Property`)
        + Имя свойства
        + Тип (см. `Typê`; подробнее о поддерживаемых типах — см. ниже)
        + Аннотации (см. `Annotation`)
        + Тип var/let (см. `Property.constant`)
        + Nullability (см. `Property.mandatory`)
    - Методы классов (см. `Method`)
        + Имя
        + Аннотации (см. `Annotation`)
        + Возвращаемый тип (`Typê`)
        + Тело функции (набор `SourceCodeLine`)
        + Набор аргументов (см. `Argument`)
            * Имя аргумента
            * Имя аргумента внутри тела метода
            * Тип аргумента `Typê`
            * Nullability 
            * Аннотации (`Annotation`; подробнее об аннотациях аргментов см. ниже)

**Кажый** модельный класс (`Annotation, Argument, Klass, Method, Property, Typê, Protokol, SourceCodeFile, SourceCodeLine`) поддерживает сравнение `==` (протокол `Equatable`) и свойство `description` (протокол `CustomStringConvertible`).

## Установка

#### CocoaPods:

`pod 'ModelCompiler', :git => 'git@git.redmadrobot.com:foundation-ios/ModelCompiler.git', :branch => 'master'`

#### Git Submodule:

`git@git.redmadrobot.com:foundation-ios/ModelCompiler.git`

## Использование:

Входная точка для использования библиотеки — класс `Compiler`.

Класс `Compiler` предоставляет конструктор с обязательным параметром `verbose` (тип `Bool`):

```Swift
let compiler = Compiler(verbose: true)
```

Параметр `verbose` позволяет использовать отладочный режим, в котором каждый распознанный элемент исходного кода будет подсвечен warning`ом с соответствующим описанием того, что конкретно было распознано, и какими свойствами распознанный элемент обладает.

`Compiler` использует в качестве входных данных объекты типа `SourceCodeFile`. Каждый экземпляр `SourceCodeFile` должен содержать в себе **полный** путь к файлу `filename` и набор строк кода `lines`.

Строка кода тоже является объектом (`SourceCodeLine`), и также включает **полный** путь к файлу `filename`, плюс номер строки `lineNumber` и саму строку `line`.

Предполагается, что при использовании библиотеки файлы исходного кода загружаются в объекты `String`, и далее преобразуются в `SourceCodeFile` посредством конструктора

```Swift
let file = SourceCodeFile(filename: "Account.swift", contents: "...")
```

В ходе распознавания компилятор может бросить исключение `CompilerMessage`, которое при выводе через `print(compilerMessage)` автоматически приводится к формату, известному IDE Xcode. «Сообщения» в этом формате выводятся прямо в исходный код в виде привычных warning'ов и error'ов с человекочитаемыми описаниями.

```Swift
do {
    return try Compiler(verbose: debugMode).compile(file: code)
} catch let error as CompilerMessage {
    print(error)
} catch {
    // ничего не делать
}
```

## Конвенция

Файл игнорируется компилятором при наличии аннотации @ignore в любой точке этого файла. Подробнее об аннотациях см. ниже.

```Swift
/** 
 Нижеследующий исходный код описывает конвенцию, которую
 поддерживает текущая редакция «компилятора».

 Существует несколько ключевых правил, которым следует
 компилятор, и которые необходимо соблюдать для того, 
 чтобы код был правильно распознан.

 1. Исходный код не должен содержать лишних пробелов, а также
 не должен содержать лишних пустых строк.
 Компилятор выделяет слова по пробелам или переносам строк.
 Соответственно, запись JSONParser<Model> для компилятора
 является одним словом.

 2. Компилятор оперирует строками. Если переменная и её 
 тип располагаются на разных строках — такой код не будет
 воспринят.

 3. Декларации различных элементов исходного кода стоит
 разносить на разные строки. Если имя функции и набор её
 параметров будут располагаться на разных строках — такой
 код будет воспринят правильно.

 4. Явное лучше, чем неявное. Компилятор ограниченно поддерживает
 выведение типов переменных, но лучше всегда указывать тип явно.

 5. Компилятор ориентируется по ключевым словам class, protocol,
 var, let, func и init, а также по скобкам {}, (), [], двоеточиям
 и символу ->.

 Настоятельно рекомендуется использовать существующую
 конвенцию расположения фигурных и других скобок в классах, методах
 и других конструкциях.
 */

/**
 В одном файле исходного кода может быть только одна ключевая
 сущность. В качестве такой сущности может выступать класс 
 (опознаётся по ключевому слову class) или протокол (опознаётся
 по ключевому слову protocol).

 Компилятор игнорирует модификаторы доступа и другие директивы,
 относящиеся к декларации класса. 

 Компилятор вычисляет наличие parent'a по наличию двоеточия
 в строке декларации. Если класс наследуется от другого класса,
 а также реализовывает один или несколько протоколов — в качестве
 parent'a распознаётся первое слово после двоеточия. Запятая после
 первого слова автоматически обрезается.

 Содержимое класса начинается с фигурной скобки {
 Такая фигурная скобка может располагаться на одной строке с 
 декларацией класса.

 Если фигурная скобка { находится внутри блочного комментария 
 /** ... */ — то она игнорируется.

 Содержимое класса оканчивается фигурной скобкой }
 Такая фигурная скобка должна располагаться вне блочного 
 комментария /** .. */

 Теоретически, наличие фигурной скобки } не является обязательным.

 Для распознавания элементов класса компилятор использует
 scope, заданный фигурными скобками. Если компилятор
 обнаруживает ещё одну скобку {, глубина scope возрастает.
 При обнаружении } вне комментария глубина scope уменьшается.

 Более глубокий scope, отличный от класса, считается частью методов
 или других конструкций языка. Ключевые слова var, let, func и пр. 
 для такого scope игнорируются.

 @documentation omg!
 */
public class Entity: CoreDAO.Entity {

   /**
    KLASS
    name = Entity
    parent = CoreDAO.Entity
    annotations = [
       { name = documentation; value = omg! }
    ]
    */

   /**
    Идентификатор сущности.
    @json id
    */
    var id: Int 

   /**
    PROPERTY
    name = id
    type = .IntType
    mandatory = true
    constant = false
    annotations = [
        { name = json; value = id }
    ]
    */

   /**
    Название сущности.
    */
    let name = "Entity"

   /**
    PROPERTY
    name = name
    type = .StringType
    mandatory = true
    constant = true
    annotations = []
    */ 

   /**
    Поле сущности с getter- и setter-методами.
    Конвенция фигурных скобок такая же, как и у методов.
    @sleep
    */
    var creationDate: NSDate?
    {
        get {
            return nil
        }
        set(newDate) {
            // ничего не делать
        }
    }

   /**
    PROPERTY
    name = creationDate
    type = .DateType
    mandatory = false
    constant = false
    annotations = [
        { name = sleep; value = nil }
    ]
    */ 

   /**
    Конструктор.
    */ 
    override init(
        id entityId: Int, // @id
        creationDate: NSDate?
    )
    {
        self.creationDate = creationDate
        self.id = entityId
        super.init(id: entityId, creationDate: creationDate)
    }

   /**
    METHOD
    name = "init"
    returnType = .ObjectType("Self")
    annotations = []
    arguments = [
        ARGUMENT {
            name = id
            bodyName = entityId
            type = .IntType
            mandatory = true
            annotations = [{ name = id; value = nil }]
        }
        ARGUMENT {
            name = creationDate
            bodyName = creationDate
            type = .DateType
            mandatory = false
            annotations = []
        }
    ]
    */ 

}

```

## Поддерживаемые типы `Typê`

В текущей редакции «компилятор» поддерживает набор примитивных типов:

```Swift
.BoolType
.IntType
.FloatType
.DoubleType
.StringType
```

Также поддерживаются типы коллекций и объектов:

```Swift
.DateType                                  // variable: NSDate()
.ObjectType(name: String)                  // variable: Name()
.ArrayType(item: Typê)             // variable: [Item]()
.MapType(pair: (key, value: Typê)) // variable: [Key:Value]
```

Перечисление `Typê` поддерживает протокол `CustomStringConvertible`:
```Swift
let type: Typê = ...
let message: String = "Type is \(type)"

.BoolType           => "Bool"
.IntType            => "Int"
.FloatType          => "Float"
.DoubleType         => "Double"
.StringType         => "String"
.DateType           => "NSDate"
.ObjectType(Name)   => "Name"
.ArrayType(Item)    => "[Item]"
.MapType(pair)      => "[pair.key : pair.value]"
```

## Формат аннотаций `Annotation`

Аннотации к элементам исходного кода располагаются в соответствующих комментариях к этим элементам.

«Компилятор» умеет распознавать аннотации из inline-комментариев `// текст` и блочных комментариев в формате:
```Swift
/**
 Имя.
 */
 var name: String
```

Комментарии в других форматах не поддерживаются. 

**Важно!** Для блочных комментариев действует правило, при котором для любого элемента исходного кода без документации будет применен ближайший блочный комментарий сверху:

```Swift
/**
 Этот комментарий будет применен для свойств propertyOne И propertyTwo.
 */
 var propertyOne: Int = 1

 let propertyTwo: String = "ABC"
```

**Аннотации распознаются** по символу `@` в тексте комментария: 
```Swift
/**
 @ignore
 @name Operator
 */
```

Каждая аннотация должна содержать имя, а также может содержать значение. Имя и значение не могут содержать пробелов и переносов строки.

Комментарий выше содержит аннотации `ignore` и `name`, символ `@` не включается в имя аннотации. 

**Для аргументов методов** действует ограничение: аннотации должны содержаться в inline-комментарии к аргументу, а сами аргументы (если их больше одного) придётся расположить на отдельных строках. Кроме того, для корректного распознавания нескольких аннотаций, расположенных друг за другом в одной строке, рекомендуется использование формата `@аннотация значение` с обязательным указанием значения.

Корректно распознаются следующие варианты:

**I**
```Swift
public override init(
    name: String, // @json name
    familyName: String // @json family_name @mandatory _
)
```

**II**
```Swift
public func make(firstName name: String, // @json
    lastName familyName: String // @json
)
```
